start phase EntryPoint {
    info = "Denotes the entry point of your compiler",
    
    actions {
        pass SPdoScanParse;
        CollectInfo;
        LookupTables;
        StrengthReduction;
        Print;
    }
};

traversal Print {
    uid = PRT
};

traversal StrengthReduction {
    uid = SR,
    nodes = { Binop }
};

traversal CollectInfo {
    uid = CI,
    nodes = { Module, Binop },
    travdata {
        int plus,
        int minus,
        int mul,
        int div,
        int mod
    }
};

traversal LookupTables {
    uid = LT,
    nodes = { Stmts, Var, VarLet },
    travdata {
        user htable_ptr id_table,
        bool first_stmts
    }
};


phase Demo {
    actions { 
        traversal RenameIdentifiers {
            uid = RI,
            nodes = { Var, VarLet }
        };

        traversal SumInts {
            uid = SI,
            nodes = { Stmts, Num },
            travdata {
                int sum
            }
        };

        traversal OptSubstraction {
            uid = OS,
            nodes = { Binop }
        };
    }
};


/*** AST ***/

enum monop_type {
    prefix = MO,
    values {
        not, neg
    }
};

enum binop_type {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

enum basic_type {
    prefix = BS,
    values {
        int_type, float_type, bool_type
    }
};

nodeset Expr = {Num, Float, Bool, Binop, Monop, Func, Var};
nodeset Stmt = {Var_dec, Assign, Func, If_stmt, Whl_stmt, For_stmt, Ret_stmt};
nodeset Assignment = {Assign};

// Nodes you want to be able to link to from your symbol table.
nodeset Link = Expr | Assignment;

root node Module {
    children {
        Stmts next { constructor, mandatory }
    },

    attributes {
        int plus,
        int minus,
        int mul,
        int div,
        int mod
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Var_dec {
    children {
        VarLet let { constructor, mandatory },
        Expr expr { constructor }
    },

    attributes {
        basic_type type { constructor }
    }
};

node Func {
    children {
        Arg arguments { constructor }
    },

    attributes {
        string name { constructor }
    }
};

node Arg {
    children {
        Expr expr { constructor, mandatory },
        Arg next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node If_stmt {
    children {
        Expr condition { constructor },
        Block content { constructor, mandatory },
        If_stmt elif { constructor }
    }
};

//node Cond {
//    children {
//        Expr expr { constructor }
//    }
//};

node Whl_stmt {
    children {
        Expr condition { constructor, mandatory },
        Block content { constructor, mandatory }
    },

    attributes {
        bool do_key { constructor }
    }
};

node For_stmt {
    children {
        Assign init { constructor, mandatory },
        Expr condition { constructor, mandatory },
        Expr step { constructor },
        Block content { constructor, mandatory }
    }
};

node Ret_stmt {
    children {
        Expr expr { constructor }
    }
};

node Block {
    children {
        Stmts content { constructor }
    }
};

node Binop {
    children {
        Expr left  { constructor, mandatory },
        Expr right { constructor, mandatory }
    },
    
    attributes {
        binop_type type { constructor }
    }
};

node Monop {
    children {
        Expr right { constructor, mandatory }
    },

    attributes {
        monop_type type { constructor }
    }
};

node Cast {
    children {
        Expr expr { constructor, mandatory }
    },

    attributes {
        basic_type type { constructor }
    }
};

// Variable in assignment.
node VarLet {
    attributes {
        string name { constructor },
        Link decl
    }
};

// Variable in an expression.
node Var {
    attributes {
        string name { constructor },
        Link decl
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};

/* Symbol table entry
 * TODO: fill in.
node Ste {

}
*/



